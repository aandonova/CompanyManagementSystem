import { reflow } from '../util/util';
/**
 * Defines the carousel slide transition direction.
 */
export var NgbSlideEventDirection;
(function (NgbSlideEventDirection) {
    NgbSlideEventDirection["LEFT"] = "left";
    NgbSlideEventDirection["RIGHT"] = "right";
})(NgbSlideEventDirection || (NgbSlideEventDirection = {}));
const isAnimated = ({ classList }) => {
    return classList.contains('carousel-item-left') || classList.contains('carousel-item-right');
};
const ɵ0 = isAnimated;
const removeDirectionClasses = ({ classList }) => {
    classList.remove('carousel-item-left');
    classList.remove('carousel-item-right');
};
const ɵ1 = removeDirectionClasses;
const removeClasses = ({ classList }) => {
    removeDirectionClasses({ classList });
    classList.remove('carousel-item-prev');
    classList.remove('carousel-item-next');
};
const ɵ2 = removeClasses;
export const ngbCarouselTransitionIn = (element, { direction }) => {
    const { classList } = element;
    if (isAnimated(element)) {
        // Revert the transition
        removeDirectionClasses(element);
    }
    else {
        // For the 'in' transition, a 'pre-class' is applied to the element to ensure its visibility
        classList.add('carousel-item-' + (direction === NgbSlideEventDirection.LEFT ? 'next' : 'prev'));
        reflow(element);
        classList.add('carousel-item-' + direction);
    }
    return () => {
        removeClasses(element);
        classList.add('active');
    };
};
export const ngbCarouselTransitionOut = (element, { direction }) => {
    const { classList } = element;
    //  direction is left or right, depending on the way the slide goes out.
    if (isAnimated(element)) {
        // Revert the transition
        removeDirectionClasses(element);
    }
    else {
        classList.add('carousel-item-' + direction);
    }
    return () => {
        removeClasses(element);
        classList.remove('active');
    };
};
export { ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwtdHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvbW9rb3Jva292L0Rldi9Bbmd1bGFyL2NvcmUvc3JjLyIsInNvdXJjZXMiOlsiY2Fyb3VzZWwvY2Fyb3VzZWwtdHJhbnNpdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRXBDOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksc0JBR1g7QUFIRCxXQUFZLHNCQUFzQjtJQUNoQyx1Q0FBYSxDQUFBO0lBQ2IseUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBSFcsc0JBQXNCLEtBQXRCLHNCQUFzQixRQUdqQztBQUlELE1BQU0sVUFBVSxHQUFHLENBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxFQUFFO0lBQ2pDLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUMvRixDQUFDLENBQUM7O0FBRUYsTUFBTSxzQkFBc0IsR0FBRyxDQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsRUFBRTtJQUM3QyxTQUFTLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDdkMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzFDLENBQUMsQ0FBQzs7QUFFRixNQUFNLGFBQWEsR0FBRyxDQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsRUFBRTtJQUNwQyxzQkFBc0IsQ0FBQyxFQUFDLFNBQVMsRUFBQyxDQUFDLENBQUM7SUFDcEMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3ZDLFNBQVMsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQ2hDLENBQUMsT0FBb0IsRUFBRSxFQUFDLFNBQVMsRUFBaUIsRUFBRSxFQUFFO0lBQ3BELE1BQU0sRUFBQyxTQUFTLEVBQUMsR0FBRyxPQUFPLENBQUM7SUFDNUIsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDdkIsd0JBQXdCO1FBQ3hCLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ2pDO1NBQU07UUFDTCw0RkFBNEY7UUFDNUYsU0FBUyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLFNBQVMsS0FBSyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNoRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEIsU0FBUyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsQ0FBQztLQUM3QztJQUVELE9BQU8sR0FBRyxFQUFFO1FBQ1YsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRU4sTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQ2pDLENBQUMsT0FBb0IsRUFBRSxFQUFDLFNBQVMsRUFBaUIsRUFBRSxFQUFFO0lBQ3BELE1BQU0sRUFBQyxTQUFTLEVBQUMsR0FBRyxPQUFPLENBQUM7SUFDNUIsd0VBQXdFO0lBQ3hFLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZCLHdCQUF3QjtRQUN4QixzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNqQztTQUFNO1FBQ0wsU0FBUyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsQ0FBQztLQUM3QztJQUVELE9BQU8sR0FBRyxFQUFFO1FBQ1YsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtOZ2JUcmFuc2l0aW9uU3RhcnRGbn0gZnJvbSAnLi4vdXRpbC90cmFuc2l0aW9uL25nYlRyYW5zaXRpb24nO1xuaW1wb3J0IHtyZWZsb3d9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY2Fyb3VzZWwgc2xpZGUgdHJhbnNpdGlvbiBkaXJlY3Rpb24uXG4gKi9cbmV4cG9ydCBlbnVtIE5nYlNsaWRlRXZlbnREaXJlY3Rpb24ge1xuICBMRUZUID0gJ2xlZnQnLFxuICBSSUdIVCA9ICdyaWdodCdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOZ2JDYXJvdXNlbEN0eCB7IGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JzsgfVxuXG5jb25zdCBpc0FuaW1hdGVkID0gKHtjbGFzc0xpc3R9KSA9PiB7XG4gIHJldHVybiBjbGFzc0xpc3QuY29udGFpbnMoJ2Nhcm91c2VsLWl0ZW0tbGVmdCcpIHx8IGNsYXNzTGlzdC5jb250YWlucygnY2Fyb3VzZWwtaXRlbS1yaWdodCcpO1xufTtcblxuY29uc3QgcmVtb3ZlRGlyZWN0aW9uQ2xhc3NlcyA9ICh7Y2xhc3NMaXN0fSkgPT4ge1xuICBjbGFzc0xpc3QucmVtb3ZlKCdjYXJvdXNlbC1pdGVtLWxlZnQnKTtcbiAgY2xhc3NMaXN0LnJlbW92ZSgnY2Fyb3VzZWwtaXRlbS1yaWdodCcpO1xufTtcblxuY29uc3QgcmVtb3ZlQ2xhc3NlcyA9ICh7Y2xhc3NMaXN0fSkgPT4ge1xuICByZW1vdmVEaXJlY3Rpb25DbGFzc2VzKHtjbGFzc0xpc3R9KTtcbiAgY2xhc3NMaXN0LnJlbW92ZSgnY2Fyb3VzZWwtaXRlbS1wcmV2Jyk7XG4gIGNsYXNzTGlzdC5yZW1vdmUoJ2Nhcm91c2VsLWl0ZW0tbmV4dCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5nYkNhcm91c2VsVHJhbnNpdGlvbkluOiBOZ2JUcmFuc2l0aW9uU3RhcnRGbjxOZ2JDYXJvdXNlbEN0eD4gPVxuICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCwge2RpcmVjdGlvbn06IE5nYkNhcm91c2VsQ3R4KSA9PiB7XG4gICAgICBjb25zdCB7Y2xhc3NMaXN0fSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoaXNBbmltYXRlZChlbGVtZW50KSkge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgcmVtb3ZlRGlyZWN0aW9uQ2xhc3NlcyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciB0aGUgJ2luJyB0cmFuc2l0aW9uLCBhICdwcmUtY2xhc3MnIGlzIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgdG8gZW5zdXJlIGl0cyB2aXNpYmlsaXR5XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Nhcm91c2VsLWl0ZW0tJyArIChkaXJlY3Rpb24gPT09IE5nYlNsaWRlRXZlbnREaXJlY3Rpb24uTEVGVCA/ICduZXh0JyA6ICdwcmV2JykpO1xuICAgICAgICByZWZsb3coZWxlbWVudCk7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Nhcm91c2VsLWl0ZW0tJyArIGRpcmVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlbW92ZUNsYXNzZXMoZWxlbWVudCk7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbmdiQ2Fyb3VzZWxUcmFuc2l0aW9uT3V0OiBOZ2JUcmFuc2l0aW9uU3RhcnRGbjxOZ2JDYXJvdXNlbEN0eD4gPVxuICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCwge2RpcmVjdGlvbn06IE5nYkNhcm91c2VsQ3R4KSA9PiB7XG4gICAgICBjb25zdCB7Y2xhc3NMaXN0fSA9IGVsZW1lbnQ7XG4gICAgICAvLyAgZGlyZWN0aW9uIGlzIGxlZnQgb3IgcmlnaHQsIGRlcGVuZGluZyBvbiB0aGUgd2F5IHRoZSBzbGlkZSBnb2VzIG91dC5cbiAgICAgIGlmIChpc0FuaW1hdGVkKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgdHJhbnNpdGlvblxuICAgICAgICByZW1vdmVEaXJlY3Rpb25DbGFzc2VzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnY2Fyb3VzZWwtaXRlbS0nICsgZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50KTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9O1xuICAgIH07XG4iXX0=