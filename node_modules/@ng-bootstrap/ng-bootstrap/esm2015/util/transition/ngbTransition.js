import { EMPTY, fromEvent, of, race, Subject, timer } from 'rxjs';
import { endWith, filter, takeUntil } from 'rxjs/operators';
import { getTransitionDurationMs } from './util';
import { environment } from '../../environment';
import { reflow } from '../util';
const noopFn = () => { };
const ɵ0 = noopFn;
const { transitionTimerDelayMs } = environment;
const runningTransitions = new Map();
export const ngbRunTransition = (element, startFn, options) => {
    // Getting initial context from options
    let context = options.context || {};
    // Checking if there are already running transitions on the given element.
    const running = runningTransitions.get(element);
    if (running) {
        switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
                return EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.
            case 'stop':
                running.transition$.complete();
                context = Object.assign(running.context, context);
                runningTransitions.delete(element);
        }
    }
    // A reflow is required here, to be sure that everything is ready,
    // Without reflow, the transition will not be started for some widgets, at initialization time
    reflow(element);
    const endFn = startFn(element, context) || noopFn;
    // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
    // If animations are disabled, we have to emit a value and complete the observable
    // In this case we have to call the end function, but can finish immediately by emitting a value,
    // completing the observable and executing end functions synchronously.
    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        endFn();
        return of(undefined);
    }
    // Starting a new transition
    const transition$ = new Subject();
    const stop$ = transition$.pipe(endWith(true));
    runningTransitions.set(element, { transition$, context });
    const transitionDurationMs = getTransitionDurationMs(element);
    // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
    // because 'transitionend' event might not be fired in some browsers, if the transitioning
    // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
    // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
    // 2. We need to filter transition end events, because they might bubble from shorter transitions
    // on inner DOM elements. We're only interested in the transition on the 'element' itself.
    const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({ target }) => target === element));
    const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));
    race(timer$, transitionEnd$).pipe(takeUntil(stop$)).subscribe(() => {
        runningTransitions.delete(element);
        endFn();
        transition$.next();
        transition$.complete();
    });
    return transition$.asObservable();
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdiVHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvbW9rb3Jva292L0Rldi9Bbmd1bGFyL2NvcmUvc3JjLyIsInNvdXJjZXMiOlsidXRpbC90cmFuc2l0aW9uL25nYlRyYW5zaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzVFLE9BQU8sRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzFELE9BQU8sRUFBQyx1QkFBdUIsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUMvQyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFNBQVMsQ0FBQztBQWdCL0IsTUFBTSxNQUFNLEdBQXVCLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQzs7QUFFNUMsTUFBTSxFQUFDLHNCQUFzQixFQUFDLEdBQUcsV0FBVyxDQUFDO0FBQzdDLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQXNDLENBQUM7QUFFekUsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQ3pCLENBQUksT0FBb0IsRUFBRSxPQUFnQyxFQUFFLE9BQWdDLEVBQ2xFLEVBQUU7SUFFdEIsdUNBQXVDO0lBQ3ZDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQU8sRUFBRSxDQUFDO0lBRXZDLDBFQUEwRTtJQUMxRSxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEQsSUFBSSxPQUFPLEVBQUU7UUFDWCxRQUFRLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtZQUNqQyxrR0FBa0c7WUFDbEcsK0VBQStFO1lBQy9FLEtBQUssVUFBVTtnQkFDYixPQUFPLEtBQUssQ0FBQztZQUNmLDZGQUE2RjtZQUM3Rix5R0FBeUc7WUFDekcseURBQXlEO1lBQ3pELEtBQUssTUFBTTtnQkFDVCxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUMvQixPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRCxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEM7S0FDRjtJQUVELGtFQUFrRTtJQUNsRSw4RkFBOEY7SUFDOUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRWhCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDO0lBRWxELGlGQUFpRjtJQUNqRixrRkFBa0Y7SUFDbEYsaUdBQWlHO0lBQ2pHLHVFQUF1RTtJQUN2RSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsa0JBQWtCLEtBQUssTUFBTSxFQUFFO1FBQ3hGLEtBQUssRUFBRSxDQUFDO1FBQ1IsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDdEI7SUFFRCw0QkFBNEI7SUFDNUIsTUFBTSxXQUFXLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztJQUN2QyxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBQyxXQUFXLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztJQUV4RCxNQUFNLG9CQUFvQixHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTlELDJGQUEyRjtJQUMzRiwwRkFBMEY7SUFDMUYsK0ZBQStGO0lBQy9GLGtGQUFrRjtJQUNsRixpR0FBaUc7SUFDakcsMEZBQTBGO0lBQzFGLE1BQU0sY0FBYyxHQUNoQixTQUFTLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBQyxNQUFNLEVBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDekcsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixHQUFHLHNCQUFzQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRTNGLElBQUksQ0FBQyxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDakUsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25DLEtBQUssRUFBRSxDQUFDO1FBQ1IsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ25CLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sV0FBVyxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ3BDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RU1QVFksIGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgb2YsIHJhY2UsIFN1YmplY3QsIHRpbWVyfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZW5kV2l0aCwgZmlsdGVyLCB0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7Z2V0VHJhbnNpdGlvbkR1cmF0aW9uTXN9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge2Vudmlyb25tZW50fSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQge3JlZmxvd30gZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCB0eXBlIE5nYlRyYW5zaXRpb25TdGFydEZuPFQgPSBhbnk+ID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250ZXh0OiBUKSA9PiBOZ2JUcmFuc2l0aW9uRW5kRm4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgTmdiVHJhbnNpdGlvbkVuZEZuID0gKCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBOZ2JUcmFuc2l0aW9uT3B0aW9uczxUPiB7XG4gIGFuaW1hdGlvbjogYm9vbGVhbjtcbiAgcnVubmluZ1RyYW5zaXRpb246ICdjb250aW51ZScgfCAnc3RvcCc7XG4gIGNvbnRleHQ/OiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5nYlRyYW5zaXRpb25DdHg8VD4ge1xuICB0cmFuc2l0aW9uJDogU3ViamVjdDxhbnk+O1xuICBjb250ZXh0OiBUO1xufVxuXG5jb25zdCBub29wRm46IE5nYlRyYW5zaXRpb25FbmRGbiA9ICgpID0+IHt9O1xuXG5jb25zdCB7dHJhbnNpdGlvblRpbWVyRGVsYXlNc30gPSBlbnZpcm9ubWVudDtcbmNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9ucyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIE5nYlRyYW5zaXRpb25DdHg8YW55Pj4oKTtcblxuZXhwb3J0IGNvbnN0IG5nYlJ1blRyYW5zaXRpb24gPVxuICAgIDxUPihlbGVtZW50OiBIVE1MRWxlbWVudCwgc3RhcnRGbjogTmdiVHJhbnNpdGlvblN0YXJ0Rm48VD4sIG9wdGlvbnM6IE5nYlRyYW5zaXRpb25PcHRpb25zPFQ+KTpcbiAgICAgICAgT2JzZXJ2YWJsZTx1bmRlZmluZWQ+ID0+IHtcblxuICAgICAgICAgIC8vIEdldHRpbmcgaW5pdGlhbCBjb250ZXh0IGZyb20gb3B0aW9uc1xuICAgICAgICAgIGxldCBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IDxUPnt9O1xuXG4gICAgICAgICAgLy8gQ2hlY2tpbmcgaWYgdGhlcmUgYXJlIGFscmVhZHkgcnVubmluZyB0cmFuc2l0aW9ucyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ1RyYW5zaXRpb25zLmdldChlbGVtZW50KTtcbiAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLnJ1bm5pbmdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9uZSBydW5uaW5nIGFuZCB3ZSB3YW50IGZvciBpdCB0byAnY29udGludWUnIHRvIHJ1biwgd2UgaGF2ZSB0byBjYW5jZWwgdGhlIG5ldyBvbmUuXG4gICAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBlbWl0dGluZyBhbnkgdmFsdWVzLCBidXQgc2ltcGx5IGNvbXBsZXRpbmcgdGhlIG9ic2VydmFibGUgKEVNUFRZKS5cbiAgICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25lIHJ1bm5pbmcgYW5kIHdlIHdhbnQgZm9yIGl0IHRvICdzdG9wJywgd2UgaGF2ZSB0byBjb21wbGV0ZSB0aGUgcnVubmluZyBvbmUuXG4gICAgICAgICAgICAgIC8vIFdlJ3JlIHNpbXBseSBjb21wbGV0aW5nIHRoZSBydW5uaW5nIG9uZSBhbmQgbm90IGVtaXR0aW5nIGFueSB2YWx1ZXMgYW5kIG1lcmdpbmcgbmV3bHkgcHJvdmlkZWQgY29udGV4dFxuICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBvbmUgY29taW5nIGZyb20gY3VycmVudGx5IHJ1bm5pbmcgdHJhbnNpdGlvbi5cbiAgICAgICAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgICAgICAgcnVubmluZy50cmFuc2l0aW9uJC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuYXNzaWduKHJ1bm5pbmcuY29udGV4dCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcnVubmluZ1RyYW5zaXRpb25zLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIHJlZmxvdyBpcyByZXF1aXJlZCBoZXJlLCB0byBiZSBzdXJlIHRoYXQgZXZlcnl0aGluZyBpcyByZWFkeSxcbiAgICAgICAgICAvLyBXaXRob3V0IHJlZmxvdywgdGhlIHRyYW5zaXRpb24gd2lsbCBub3QgYmUgc3RhcnRlZCBmb3Igc29tZSB3aWRnZXRzLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lXG4gICAgICAgICAgcmVmbG93KGVsZW1lbnQpO1xuXG4gICAgICAgICAgY29uc3QgZW5kRm4gPSBzdGFydEZuKGVsZW1lbnQsIGNvbnRleHQpIHx8IG5vb3BGbjtcblxuICAgICAgICAgIC8vIElmICdwcmVmZXItcmVkdWNlZC1tb3Rpb24nIGlzIGVuYWJsZWQsIHRoZSAndHJhbnNpdGlvbicgd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgICAgICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBoYXZlIHRvIGVtaXQgYSB2YWx1ZSBhbmQgY29tcGxldGUgdGhlIG9ic2VydmFibGVcbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBjYWxsIHRoZSBlbmQgZnVuY3Rpb24sIGJ1dCBjYW4gZmluaXNoIGltbWVkaWF0ZWx5IGJ5IGVtaXR0aW5nIGEgdmFsdWUsXG4gICAgICAgICAgLy8gY29tcGxldGluZyB0aGUgb2JzZXJ2YWJsZSBhbmQgZXhlY3V0aW5nIGVuZCBmdW5jdGlvbnMgc3luY2hyb25vdXNseS5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnRyYW5zaXRpb25Qcm9wZXJ0eSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBlbmRGbigpO1xuICAgICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnRpbmcgYSBuZXcgdHJhbnNpdGlvblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgICAgICAgIGNvbnN0IHN0b3AkID0gdHJhbnNpdGlvbiQucGlwZShlbmRXaXRoKHRydWUpKTtcbiAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuc2V0KGVsZW1lbnQsIHt0cmFuc2l0aW9uJCwgY29udGV4dH0pO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uTXMgPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25NcyhlbGVtZW50KTtcblxuICAgICAgICAgIC8vIDEuIFdlIGhhdmUgdG8gYm90aCBsaXN0ZW4gZm9yIHRoZSAndHJhbnNpdGlvbmVuZCcgZXZlbnQgYW5kIGhhdmUgYSAnanVzdC1pbi1jYXNlJyB0aW1lcixcbiAgICAgICAgICAvLyBiZWNhdXNlICd0cmFuc2l0aW9uZW5kJyBldmVudCBtaWdodCBub3QgYmUgZmlyZWQgaW4gc29tZSBicm93c2VycywgaWYgdGhlIHRyYW5zaXRpb25pbmdcbiAgICAgICAgICAvLyBlbGVtZW50IGJlY29tZXMgaW52aXNpYmxlIChleC4gd2hlbiBzY3JvbGxpbmcsIG1ha2luZyBicm93c2VyIHRhYiBpbmFjdGl2ZSwgZXRjLikuIFRoZSB0aW1lclxuICAgICAgICAgIC8vIGd1YXJhbnRlZXMsIHRoYXQgd2UnbGwgcmVsZWFzZSB0aGUgRE9NIGVsZW1lbnQgYW5kIGNvbXBsZXRlICduZ2JSdW5UcmFuc2l0aW9uJy5cbiAgICAgICAgICAvLyAyLiBXZSBuZWVkIHRvIGZpbHRlciB0cmFuc2l0aW9uIGVuZCBldmVudHMsIGJlY2F1c2UgdGhleSBtaWdodCBidWJibGUgZnJvbSBzaG9ydGVyIHRyYW5zaXRpb25zXG4gICAgICAgICAgLy8gb24gaW5uZXIgRE9NIGVsZW1lbnRzLiBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIHRyYW5zaXRpb24gb24gdGhlICdlbGVtZW50JyBpdHNlbGYuXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkVuZCQgPVxuICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKS5waXBlKHRha2VVbnRpbChzdG9wJCksIGZpbHRlcigoe3RhcmdldH0pID0+IHRhcmdldCA9PT0gZWxlbWVudCkpO1xuICAgICAgICAgIGNvbnN0IHRpbWVyJCA9IHRpbWVyKHRyYW5zaXRpb25EdXJhdGlvbk1zICsgdHJhbnNpdGlvblRpbWVyRGVsYXlNcykucGlwZSh0YWtlVW50aWwoc3RvcCQpKTtcblxuICAgICAgICAgIHJhY2UodGltZXIkLCB0cmFuc2l0aW9uRW5kJCkucGlwZSh0YWtlVW50aWwoc3RvcCQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgcnVubmluZ1RyYW5zaXRpb25zLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGVuZEZuKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uJC5uZXh0KCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uJC5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24kLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9O1xuIl19